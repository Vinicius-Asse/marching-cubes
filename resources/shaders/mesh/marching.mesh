#!mesh shader
#version 450
#extension GL_NV_mesh_shader : require

// Número de threads por workgroup.
// Sempre com uma dimensão.
layout(local_size_x=1) in;

// Layout do primitivo construido por thread
layout(triangles) out;

// Número máximo de vértices e primitivos construidos pelo workgroup
// Se os primitivos são triangulos, max_primitives = max_vertices * 3
layout(max_vertices=18, max_primitives=6) out;

// Se não redeclararmos gl_PerVertex, irá ocorrer o seguinte erro de compilação:
// error C7592: ARB_separate_shader_objects requires built-in block gl_PerVertex to be redeclared before accessing its members
out gl_PerVertex { vec4 gl_Position; } gl_Why;

// Declaração das estruturas de saída por thread
out gl_MeshPerVertexNV { vec4 gl_Position; } gl_MeshVerticesNV[]; //[max_primitives]

out uint gl_PrimitiveCountNV;     // Número atual de triangulos construídos pelo workgroup
out uint gl_PrimitiveIndicesNV[]; // [max_primitives * 3 for triangles]

// Inclusão de métodos utilitários e tabelas constantes
#include "resources/shaders/compute/include/utils.compute"
#include "resources/shaders/compute/include/tables.compute"


// Estruturas para execução do algoritmo de Marching Cubes
out PerVertexData 
{ 
    vec4 color;
    vec4 normal;
} v_out[];

struct Triangle 
{
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 norm;
};

// Atomic buffer que armazena a quantidade de triangulos construidos
layout(binding = 0) uniform atomic_uint trianglesCount;

// SSBO da tabela de triangularização
layout(std430, binding = 1) buffer TriTable { int triTable[]; };

layout(std430, binding = 2) buffer Triangles { Triangle Data[]; };

// Matriz de Model-View-Projection utilizada para converter os pontos 3D
// Em coordenadas 2D que serão exibidas na tela
uniform mat4 MVP;

// Uniformes utilizados como parametrização do algoritmo de Marching Cubes
uniform float u_surfaceLevel;
uniform float u_smooth;
uniform uint u_linear;
uniform uint u_spheresCount;
uniform ivec3 u_pointsCount;
uniform vec3 u_worldBounds;
uniform vec4 u_spheres[15]; //15 é o número maximo permitido de pontos-esfera

const vec3 colors[4] = { 
    vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), vec3(0.0,0.0,1.0), vec3(1.0,1.0,0.0) 
};

/** Obtém o vetor normal do triangulo calculando o produto cruzado de seus vértices **/
vec4 getNormalVector(Triangle t) 
{
    vec3 a = vec3(t.v0.x, t.v0.y, t.v0.z);
    vec3 b = vec3(t.v1.x, t.v1.y, t.v1.z);
    vec3 c = vec3(t.v2.x, t.v2.y, t.v2.z);

    return vec4(normalize(cross(b - a, c - a)), 1.0);
}

/*
* Obtém o ponto intermediário entre dois pontos.
* Caso o uniform u_linear seja != 0, o ponto intermediário é calculado de acordo com o valor dos pontos.
* Caso contrário o ponto intermediário é apenas o ponto médio entre os dois pontos.
*/
vec4 interpolate(vec4 a, vec4 b) 
{
    if (u_linear != 0) 
    {
        vec3 aPos = vec3(a.x, a.y, a.z);
        vec3 bPos = vec3(b.x, b.y, b.z);

        float t = (u_surfaceLevel - a.w) / (b.w - a.w);
        vec3 i = aPos + t * (bPos - aPos); 
        return vec4(i.x, i.y, i.z, 1.0f);
    } else 
    {
        return (a + b) / 2.0f;
    }
}

/*
* Obtém a posição no vetor de triangularização utilizando cordenadas bidimencionais
*/
const int getTriTableIndex(int _x, int _y) 
{
    return _y + (_x * 16);
}

/*
* Obtém o valor de cada ponto no espaço tridimencional
*/
vec4 getPoint(uint _x, uint _y, uint _z)
{
    float x = remap(_x, 0, u_pointsCount.x - 1, -u_worldBounds.x/2.0, u_worldBounds.x/2.0);
    float y = remap(_y, 0, u_pointsCount.y - 1, -u_worldBounds.y/2.0, u_worldBounds.y/2.0);
    float z = remap(_z, 0, u_pointsCount.z - 1, -u_worldBounds.z/2.0, u_worldBounds.z/2.0);

    float value = 2.5;
    for (int i = 0; i < u_spheresCount; i++) 
    {
        float distanteToPoint = distance(vec3(x, y, z), vec3(u_spheres[i].x, u_spheres[i].y, u_spheres[i].z));
        value = smoothMin(remap(abs(distanteToPoint), 0, 5.5, -1, 1), value, u_smooth);
    }

    return vec4(x, y, z, value);
}

ivec3 _getId() 
{
    uint id = gl_GlobalInvocationID.x;
    return ivec3(id / (u_pointsCount.x * u_pointsCount.x), (id / u_pointsCount.y) % u_pointsCount.y, id % u_pointsCount.z);
}

void main()
{
    ivec3 id = _getId();

    if (
        id.x >= u_pointsCount.x - 1 || 
        id.y >= u_pointsCount.y - 1 || 
        id.z >= u_pointsCount.z - 1
    ) return;

    vec4 corners[8] = {
        getPoint(id.x    , id.y    , id.z    ),
        getPoint(id.x + 1, id.y    , id.z    ),
        getPoint(id.x + 1, id.y    , id.z + 1),
        getPoint(id.x    , id.y    , id.z + 1),
        getPoint(id.x    , id.y + 1, id.z    ),
        getPoint(id.x + 1, id.y + 1, id.z    ),
        getPoint(id.x + 1, id.y + 1, id.z + 1),
        getPoint(id.x    , id.y + 1, id.z + 1)
    };

    int index = 0;
    if (corners[0].w < u_surfaceLevel) index |=   1;
    if (corners[1].w < u_surfaceLevel) index |=   2;
    if (corners[2].w < u_surfaceLevel) index |=   4;
    if (corners[3].w < u_surfaceLevel) index |=   8;
    if (corners[4].w < u_surfaceLevel) index |=  16;
    if (corners[5].w < u_surfaceLevel) index |=  32;
    if (corners[6].w < u_surfaceLevel) index |=  64;
    if (corners[7].w < u_surfaceLevel) index |= 128;

    if (index == 0 || index == 256) return;

    for (int i = 0; triTable[getTriTableIndex(index, i)] != -1; i+=3) 
    {
        int idx = triTable[getTriTableIndex(index, i+0)];
        int idy = triTable[getTriTableIndex(index, i+1)];
        int idz = triTable[getTriTableIndex(index, i+2)];

        Triangle t;
        t.v0 = interpolate(corners[cornerListA[idx]], corners[cornerListB[idx]]);
        t.v1 = interpolate(corners[cornerListA[idy]], corners[cornerListB[idy]]);
        t.v2 = interpolate(corners[cornerListA[idz]], corners[cornerListB[idz]]);
        t.norm = getNormalVector(t);

        gl_MeshVerticesNV[gl_PrimitiveCountNV * 3 + 0].gl_Position = MVP * t.v0;
        gl_MeshVerticesNV[gl_PrimitiveCountNV * 3 + 1].gl_Position = MVP * t.v1;
        gl_MeshVerticesNV[gl_PrimitiveCountNV * 3 + 2].gl_Position = MVP * t.v2;

        v_out[gl_PrimitiveCountNV * 3 + 0].color = vec4(colors[0], 1.0);
        v_out[gl_PrimitiveCountNV * 3 + 0].normal = t.norm;

  	    v_out[gl_PrimitiveCountNV * 3 + 1].color = vec4(colors[1], 1.0);
  	    v_out[gl_PrimitiveCountNV * 3 + 1].normal = t.norm;

  	    v_out[gl_PrimitiveCountNV * 3 + 2].color = vec4(colors[2], 1.0);
  	    v_out[gl_PrimitiveCountNV * 3 + 2].normal = t.norm;

        gl_PrimitiveIndicesNV[gl_PrimitiveCountNV * 3 + 0] = gl_PrimitiveCountNV * 3 + 0;
        gl_PrimitiveIndicesNV[gl_PrimitiveCountNV * 3 + 1] = gl_PrimitiveCountNV * 3 + 1;
        gl_PrimitiveIndicesNV[gl_PrimitiveCountNV * 3 + 2] = gl_PrimitiveCountNV * 3 + 2;
        
        gl_PrimitiveCountNV = 1;
        atomicCounterIncrement(trianglesCount);
    }
}
  

#!fragment shader
#version 450
 
layout(location = 0) out vec4 FragColor;
 
in PerVertexData
{
	vec4 color;
    vec4 normal;
} fragIn;

uniform vec4 u_lightDir;
 
void main()
{
    float diffuse = max(dot(fragIn.normal, vec4(-u_lightDir.xyz, 1.0)), 0.5);
	FragColor = fragIn.color * diffuse;
}
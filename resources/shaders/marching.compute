#version 450
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_arrays_of_arrays : enable

#include "resources/shaders/include/tables.compute"

struct Triangle {
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 norm;
};

layout(local_size_x = 5, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform atomic_uint trianglesCount;

layout(std430, binding = 1) buffer Triangles 
{ 
    Triangle Data[]; 
};

layout(std430, binding = 2) buffer Points 
{ 
    vec4 points[]; 
};

uint currPosFromCord(uint x, uint y, uint z) {
    return x + (gl_NumWorkGroups.y * y) + (gl_NumWorkGroups.y * gl_NumWorkGroups.z * z);
}

ivec3 getId() {
    return ivec3(gl_WorkGroupID.x, gl_WorkGroupID.y, gl_WorkGroupID.z);
}

vec4 getNormalVector(Triangle t) {
    vec3 a = vec3(t.v0.x, t.v0.y, t.v0.z);
    vec3 b = vec3(t.v1.x, t.v1.y, t.v1.z);
    vec3 c = vec3(t.v2.x, t.v2.y, t.v2.z);

    return vec4(normalize(cross(b - a, c - a)), 1.0);
}

vec4 interpolate(vec4 a, vec4 b) {
    return (a + b) / 2;
}

void main()
{
    ivec3 id = getId();
    float surfaceLevel = -0.5;

    if (id.x >= gl_NumWorkGroups.x - 1 || id.y >= gl_NumWorkGroups.y - 1 || id.z >= gl_NumWorkGroups.z - 1)
        return;

    uint currPos = currPosFromCord(id.x, id.y, id.z);

    vec4 corners[8] = {
        points[currPosFromCord(id.x    , id.y    , id.z    )],
        points[currPosFromCord(id.x + 1, id.y    , id.z    )],
        points[currPosFromCord(id.x + 1, id.y    , id.z + 1)],
        points[currPosFromCord(id.x    , id.y    , id.z + 1)],
        points[currPosFromCord(id.x    , id.y + 1, id.z    )],
        points[currPosFromCord(id.x + 1, id.y + 1, id.z    )],
        points[currPosFromCord(id.x + 1, id.y + 1, id.z + 1)],
        points[currPosFromCord(id.x    , id.y + 1, id.z + 1)]
    };

    int index = 0;
    if (corners[0].w < surfaceLevel) index |=   1;
    if (corners[1].w < surfaceLevel) index |=   2;
    if (corners[2].w < surfaceLevel) index |=   4;
    if (corners[3].w < surfaceLevel) index |=   8;
    if (corners[4].w < surfaceLevel) index |=  16;
    if (corners[5].w < surfaceLevel) index |=  32;
    if (corners[6].w < surfaceLevel) index |=  64;
    if (corners[7].w < surfaceLevel) index |= 128;

    const uint localID = gl_LocalInvocationID.x;

    int idx = -1, idy = -1, idz = -1;
    if (localID == 0) {
        idx = triTable[0][index];
        idy = triTable[1][index];
        idz = triTable[2][index];
    } else if (localID == 1) {
        idx = triTable[3][index];
        idy = triTable[4][index];
        idz = triTable[5][index];
    } else if (localID == 2) {
        idx = triTable[6][index];
        idy = triTable[7][index];
        idz = triTable[8][index];
    } else if (localID == 3) {
        idx = triTable[9][index];
        idy = triTable[10][index];
        idz = triTable[11][index];
    } else if (localID == 4) {
        idx = triTable[12][index];
        idy = triTable[13][index];
        idz = triTable[14][index];
    } else {
        return;
    }

    if (idx == -1 || idy == -1 || idz == -1) return;

    Triangle t;
    t.v0 = interpolate(corners[cornerListA[idx]], corners[cornerListB[idx]]);
    t.v1 = interpolate(corners[cornerListA[idy]], corners[cornerListB[idy]]);
    t.v2 = interpolate(corners[cornerListA[idz]], corners[cornerListB[idz]]);
    t.norm = getNormalVector(t);

    uint atomicCounter = atomicCounterIncrement(trianglesCount);
    Data[atomicCounter] = t;
}